---
title: "dada2_GOM_2"
output: html_document
---
### This R markdown contains the analyis of output ASV table from the fitst dada2_GOM markdown. 

## Analysis in R

### setting the working directory
```{r}
# setting the right directory
setwd("C:\\Users\\MSI\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\matomo\\jacobs\\BCCB_project\\amplicon_analysis_GOM")
list.files()

# install.packages("phyloseq")
# install.packages("vegan")s
#install.packages("DESeq2")
# install.packages("ggplot2")
# install.packages("dendextend")
# install.packages("tidyr")
# install.packages("viridis")
# install.packages("reshape")
```

### loading the packages

```{r}
library("phyloseq")
library("vegan")
library("DESeq2")
library("ggplot2")
#library("dendextend")
library("tidyr")
library("viridis")
library("reshape")
library("dplyr")
```

## Checking the package version 

```{r}
packageVersion("phyloseq")
packageVersion("vegan")
packageVersion("DESeq2")
packageVersion("ggplot2") 
#packageVersion("dendextend")
packageVersion("tidyr")
packageVersion("viridis")
packageVersion("reshape")
```
This notebook was run with the following versions. The order of versions is corresponded with the script above.
[1] ‘1.28.0’
[1] ‘2.5.6’
[1] ‘1.24.0’
[1] ‘3.2.1’
[1] ‘1.0.0’
[1] ‘0.5.1’
[1] ‘0.8.8’

## Reading the exported data from the directory

```{r}
#write(asv_fasta, file = "ASVs_GOM.fa")
#write.table(asv_tab, file = "ASVs_GOM.tsv", sep = "\t", quote = F, col.names = NA)
#write.table(asv_tax, "ASVs_GOM_Taxa.tsv", sep = "\t", quote = F, col.names = NA)

# moving on to 

rm(list=ls())

#Load ASV table
count_tab <- read.table("ASVs_GOM.tsv", header=T, row.names=1, check.names=F, sep="\t")
#Load taxonomy table
tax_tab <- as.matrix(read.table("ASVs_GOM_Taxa.tsv", header=T, row.names=1, check.names=F, sep = "\t"))
#Load sample matadata file
sample_info_tab <- read.table("sample_metadata.txt", header = T, row.names = 1, check.names = F, sep = "\t")

#Check content of the metadata file
sample_info_tab

```

- **sep** = a string used to separate columns. using sep = "\t" gives tab deliminated output
- **quote** = a logical value or a numeric vector. If TRUE, any character or factor coluns will be surrounded by double quotes. If FALSE, nothing is quoted/
- **col.names** = either a logical value indicating whether the column names of x are to be written along with x, or a character vector of column names to be written. 
- **row.names** = a vector of row names. Setting it to 1 means the name of samples/ASV number is listed in the first column of the table

## Assigning contigency tables and sample metadata into phyloseq object
```{r}
#read ASV table into OTU_table class object
otu_1 <- as.matrix(count_tab)
otu_2 <- decostand(otu_1, MARGIN = 2, method = "hellinger" )
otu_i <- otu_table(otu_1, taxa_are_rows = T)
otu_d <- otu_table(otu_2, taxa_are_rows = T)
rm(otu_1)
rm(otu_2)
#read taxonomy table into tax_table class object
TAX <- tax_table(tax_tab)
#read metadata file into sample_data class object
samples <- sample_data(sample_info_tab)

#Construct phyloseq object from the component objects above. 
Ps <- phyloseq(otu_i, TAX, samples)
Ps_hellinger <- phyloseq(otu_d, TAX, samples)
#Check content of the object
Ps
Ps_hellinger
```

I kept getting an error message " Error in validObject(.Object) : invalid class “phyloseq” object: Component taxa/OTU names do not match. Taxa indices are critical to analysis. Try taxa_names()"

This was solved by replacing the parameter in line 327 'taxa_are_rows = F' to taxa_are_rows = T'

- **taxa_are_rows** =  Logical; of length 1 ignored unless object is a matrix, in which case it is required. Basically it disregards the first column

- **phyloseq()** = this function will create a phyloseq object from its component data. OTU_table class, sample_data casll and taxonomy table class. 

Summary of this phyloseq object is displayed in the output


##creating variables for subset samples from phyloseq object

```{r}
#Normalize number of reads in each sample using median sequencing depth
total = median(sample_sums(Ps))
standf = function(x, t=total) round(t *(x/ sum(x)))
Ps <- transform_sample_counts(Ps, standf)


# Keep taxa of interests from the publication. 
ps_class <- subset_taxa(Ps, Class %in% c("Deltaproteobacteria", "Gammaproteobacteria", "Nitrososphaeria", "Alphaproteobacteria", "Phycisphaerae", "Planctomycetacia", "Anaerolineae", "Gemmatimonadetes", "Nitrospira", "Acidimicrobiia", "Subgroup_22", "Acidobacteria"))



ps_class

# subset samples from whole data set. (In this case different sampling sites.)
DSH08 <- subset_samples(ps_class, sample_sites=="DSH08")
DSH09 <- subset_samples(ps_class, sample_sites=="DSH09")
DSH10 <- subset_samples(ps_class, sample_sites=="DSH10")
IXW250 <- subset_samples(ps_class, sample_sites=="IXW250")
IXW500 <- subset_samples(ps_class, sample_sites=="IXW500")
IXW750 <- subset_samples(ps_class, sample_sites=="IXW750")


```

## producing community composition bar plots
```{r}
source("bar_plot.R")
show(D08)
show(D10)
show(D09)
show(I25)
show(I50)
show(I75)
```

- **tax_glom()** = This function merges species that have the same taxonomy at a certain taxonomic rank. WHen selecting "Class", class taxonomic rank is selected for variable assignment. 
- **transform_sample_counts()** = This function transforms the sample counts of a taxa abundance matrix according to a user provided function. As shown above 'function(x) x/sum(x)' is used to calculate the relative sequence abundance. 
- **ggplot()** = ggplot initializes a ggplot object.
- **ggtitle()** = this function adds title in the plot. 
- **scale_x_discrete()** = This function allows to modify grid and axis title of x-axis. For instance **limits** parameter is used to set axis points for the plot. 

Class is chosen for taxonomy rank for this bar plot. Function ggtitle() is used to display titile of each bar plot. 


### Generation of heatmap

Let's create a basic heatmap using default parameters
```{r}
#Heatmap for each sampling site

#Merge abundance count together for each sampling site. 
Ps_sample_id <- merge_samples(Ps, "sample_sites")
#plot
plot_heatmap(Ps, method = "NMDS", distance = "bray", taxa.label = "Phylum", taxa.order = "Phylum", "sample_name", high = "red", low = "beige", na.value = "beige", max.label = ntaxa(Ps)) + labs(y = "ASVs", x = "sampling sites")

```

- **method** = The ordination method to use for organizing the heatmap. NMDS is used as a method to plot a heatmap for this data. 
-**distance** = A character string. The ecological distance method to use in the ordination. "bray" = bray curtis dissimilarity

As shown in the heatmap, it is very clustered and difficult to distinct high abundance ASVs. It can be process in a way that only OTUs with >20% abundance are selected in the heatmap. To do this,,

```{r}
#This command gives an error message. 
# Ps_sample_id_filterd <- filter_taxa(Ps_sample_id, function(x) sum(x > total * 0.2) > 0, prune = TRUE)
# keepTaxa <- ((apply(otu_table(Ps_sample_id) >= 0.005,1,sum,na.rm=TRUE) > 2) | (apply(otu_table(Ps_sample_id) >= 0.05, 1, sum,na.rm=TRUE) > 0))
# table(keepTaxa)
# yo <- prune_taxa(keepTaxa, Ps_sample_id)
# plot_heatmap(yo, "NMDS", "bray")

plot_heatmap(Ps, "sample_sites", taxa.order = "Kingdom" )
```
However, it kept getting an error stating that 'OTU abundance data must have non-zero dimensions filter_taxa' and the solution is not yet to be found. This will be posted on Github issue. 


Rarefaction curve with iNEXT package

### Installation of iNEXT package from Cran
```{r}
#Install from Cran
#install.packages("iNEXT")

#import package

library(iNEXT)

#package.version("iNEXT")

```

iNEXT function only allws data frame or contigency table as input, so if samples were grouped or names of columns were changed in phyloseq, it is important to transform a phyloseq oject into a data frame. For my case, column names of the original table are accession numbers from NCBI and the names need to be changed to individual sediment depth of sample extraction with name of sampling site. 
```{r}

#Change name of column by individual sediment depths
Ps_sample_name <- merge_samples(Ps, "sample_name")
otu_table_site <- as(otu_table(Ps_sample_name), "matrix")
if(!taxa_are_rows(Ps_sample_name)){otu_table_site <- t(otu_table_site)}
otu_table_site_df <- as.data.frame(otu_table_site)
otu_table_site_df
```

```{r}
# rarefaction curve for 
out <- iNEXT(otu_table_site_df, q=0, datatype = "abundance")
out$DataInfo

ggiNEXT(out, type=1, se= TRUE, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("Sample size")
ggiNEXT(out, type=2, se = TRUE, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("Sample completeness curve")
ggiNEXT(out, type=3, se = TRUE, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("Coverage based curve")
```

There are three types of curves plotted above.

- **Type 1** = Sample- size based R/E curve. This curve plots diversity estimates with confidence intervals as a function of sample size up to double the reference sample size.
- **Type 2** = sample completeness curve with confidence intervals. This curve plots the sample coverage with respect to sample size for the same range with type 1 plot
- **Type 3** = Coverage based R/E curve, This curve plots the diversity estimates with confidence intervals as a function of sample coverage up to the maximum coverage obrained from the maximum size described in type 1
- **knots** = an integer specifying the numver of equally-spaced knots between size 1 andthe endpoint. Since my data set is large and the compational time takes forever, the knots parameter is set to 100 to draw the rarefaction curves. 
- **conf** = a positive number <1 specifying the level of condence interval. I do not wish to calculate the confidence interval. Therefore, the value is set to NULL. 
- **se** = if TRUE, it plots confidence intervals. 
- **theme()** = Changing legend text font size. 
- **ggtitle()** = add title to plot. 
-


As displayed in out$Datainfo, the lowest number of individuals per sample is 4864 from sample name SRR6172267. To rarefy the diversities of all localities to the lowest number of observed individuals per localitiy which is 4864, endpoint is set to 4846 and the rarefaction curves are plotted below. 
```{r}
# rarefaction curve with endpoint
out_4864 <- iNEXT(count_tab, q=c(0,1,2),  datatype = "abundance", endpoint = 4846, knots = 1000) 
ggiNEXT(out_4864, type = 1, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("endpoint = 4846")
ggiNEXT(out, type=2, se = TRUE, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("endpoint = 4846")
ggiNEXT(out, type=3, se = TRUE, facet.var = "order", color.var = "site") + theme(legend.text = element_text(size = 7)) + ggtitle("endpoint = 4846")

```

See rarefaction curve by sampling sites. 
```{r}
out_by_site <- iNEXT(otu_table_site_df, q=0, datatype = "abundance")
out_by_site$DataInfo
ggiNEXT(out_by_site, type=1, se= TRUE, facet.var = "order", color.var = "site") + ggtitle("by sites")
ggiNEXT(out_by_site, type=2, se = TRUE, facet.var = "order", color.var = "site") + ggtitle("by sites")
ggiNEXT(out_by_site, type=3, se = TRUE, facet.var = "order", color.var = "site")  + ggtitle("by sites")
```

### - **q** = iNEXT focuses on three measures of Hill numbers of order q: species richness (q = 0), Shannon diversity (q = 1, the exponential of Shannon entropy) and Simpson diversity (q = 2, the inverse of Simpson concentration)

## Plotting Chao1 richness estimator and Shannon diversity estimator. 

Chao1 estimator is measured by the number of observed species plus number of singletons divided by two times of number of doubletons. Chao1 estimates the number of species that are represented only by a single indivudal or by two inviduals in that sample based on abundances.

Shannon diversity estimator shows both richness and evenness of species abundance. In other words, if a sample has high shannon diversity index, the sample is thought to be more 'diverse' compared to those samples with lower diversity index 

```{r}

#plot alpha diversity by samples

plot_richness(Ps, measures = c("Chao1", "Shannon"), x="sample_name", color = "environment" )
```


```{r}

# plot alpha diversity by sampling sites

plot_richness(Ps, measures = c("Chao1", "Shannon"), x="sample_sites", color="depth") + labs(x = "Sampling sites")
```





## Beta Diversity 

Beta diversity measures microbial community differences between samples/environments.  

## Hiracheal clustering dendrogram
```{r}
#Caluclate distances
d <- phyloseq::distance(Ps_hellinger, method = "bray", type = "samples")
# Hierarchical cluster analysis on a set of dissimilarities
p.hclust <- hclust(d, method = "average")

plot(p.hclust)
  
  
```


The method of scaling is Bray Curtis dissimilarity index. Samples with a higher division point (e.g. 0.8) indicate greater dissimilarity from each other. On the other hand, samples that are similar to each other are found at the lower division point.

- **distance(): method** = A character string. Method for distance calculation. Detailed list can be found in distanceMethodList. Bray Curtis dissimilarity is used for my dataset 
- **type** = A character string. The type of pairwise comparisons being calculated: Either sample or taxa.  
- **hclust(): method** = the agglomeration method to be used: "ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", or "centroid"

## NMDS ordination plot

```{r}
Ps.ord <- ordinate(Ps_hellinger, method="NMDS", distance = "bray")

# Within North Gulf of Mexico
NGOM <- subset_samples(Ps_hellinger, environment == "NGoM")
NGOM.ord <- ordinate(NGOM, method = "NMDS", distance = "bray")

# Within South Gulf of Mexico
SGOM <- subset_samples(Ps_hellinger, environment == "SGoM")
SGOM.ord <- ordinate(SGOM, method = "NMDS", distance = "bray")

```


It shows a warning message stating that "stress is (nearly) zero: you may have insufficient dataskipping half-change scaling: too few points below threshold"


```{r}
# Plot NMDS by samples
plot_ordination(Ps_hellinger, Ps.ord, type= "samples", color = "sample_sites", title = "sample")
# Plot NMDS by geographical locations (North or South Gulf of Mexico
plot_ordination(Ps_hellinger, Ps.ord, type= "sites", color = "environment", title = "sample")
# Plot NMDS by sediment depth
plot_ordination(Ps_hellinger, Ps.ord, type= "samples", color = "depth", title = "sample")

```

```{r}
# Plot NMDS of NGOM by samples
plot_ordination(NGOM, NGOM.ord, type="samples", color = "depth", shape = "sample_sites", title = "sample")

# Plot NMDS of SGOM by samples
plot_ordination(SGOM, SGOM.ord, type="samples", color = "depth", shape = "sample_sites", title = "sample")

```

This NMDS plot does not look right. All the data points are aligned on two lines at -0.50 and 0.50. 

- **type** = The plot type. "samples" "taxa", or "biplot".
- **color** = This parameter allows you to change the color of data points based on metadata table. 

## MDS ordination plot

```{r}
#Calculate distance

Ps_wuf.dist <- ordinate(Ps_hellinger, "MDS", "bray")

#PLot
#by sample sites
plot_ordination(Ps_hellinger, Ps_wuf.dist, color = "sample_sites")
#by geographical location 
plot_ordination(Ps_hellinger, Ps_wuf.dist, color = "environment")
#by depth
plot_ordination(Ps_hellinger, Ps_wuf.dist, color = "depth")
```


## Redundancy analysis 
```{r}
Ps.rda <- ordinate(Ps_hellinger, method = "RDA", distance = "bray", formula = ~ water_depth + depth + environment)

# Plot
RDA <- plot_ordination(Ps_hellinger, Ps.rda, type = "samples", color="depth", shape = "sample_sites")

RDA

# Now add the environmental variables as arrows
arrowmat = vegan::scores(Ps.rda, display = "bp")
# Add labels, make a data.frame
arrowdf <- data.frame(labels = rownames(arrowmat), arrowmat)
# Define the arrow aesthetic mapping
arrow_map = aes(xend = RDA1, yend = RDA2, x = 0, y = 0, shape = NULL, color = NULL, label = labels)

arrowhead = arrow(length = unit(0.05, "npc"))


label_map <- aes(x = 1.2 * RDA1, 
    y = 1.2 * RDA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

# Make a new graphic
RDA + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 5,  
    data = arrowdf, 
    show.legend = FALSE
  )



```
